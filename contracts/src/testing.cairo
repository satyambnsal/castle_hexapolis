#[cfg(test)]
mod tests {
    use core::array::ArrayTrait;
    use starknet::class_hash::Felt252TryIntoClassHash;
    use starknet::ContractAddress;
    use debug::PrintTrait;

    // import world dispatcher
    use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};

    // import test utils
    use dojo::test_utils::{spawn_test_world, deploy_contract};

    // import model structs
    // the lowercase structs hashes generated by the compiler
    use castle_hexapolis::models::{
        Tile, TileType, Score, RemainingMoves, PlayerId, PlayerAddress, GameData, tile, score,
        remaining_moves, player_id, player_address, game_data
    };

    // import actions dojo contract
    use castle_hexapolis::actions::actions;

    // import interface
    use castle_hexapolis::interface::{IActions, IActionsDispatcher, IActionsDispatcherTrait};

    // import config
    use castle_hexapolis::config::{GRID_SIZE, REMAINING_MOVES_DEFAULT};

    // NOTE: Spawn world helper function
    // 1. deploys world contract
    // 2. deploys actions contract
    // 3. sets models within world
    // 4. returns caller, world dispatcher and actions dispatcher for use in testing!
    fn spawn_world() -> (ContractAddress, IWorldDispatcher, IActionsDispatcher) {
        let caller = starknet::contract_address_const::<'jon'>();

        // This sets caller for current function, but not passed to called contract functions
        starknet::testing::set_caller_address(caller);

        // This sets caller for called contract functions.
        starknet::testing::set_contract_address(caller);

        // NOTE: Models
        // we create an array here to pass to spawn_test_world. This 'sets' the models within the world.
        let mut models = array![
            tile::TEST_CLASS_HASH,
            score::TEST_CLASS_HASH,
            remaining_moves::TEST_CLASS_HASH,
            player_id::TEST_CLASS_HASH,
            player_address::TEST_CLASS_HASH,
            game_data::TEST_CLASS_HASH
        ];

        // deploy world with models
        let world = spawn_test_world(models);

        // deploy systems contract
        let contract_address = world
            .deploy_contract('actions', actions::TEST_CLASS_HASH.try_into().unwrap());

        // returns
        (caller, world, IActionsDispatcher { contract_address })
    }

    #[test]
    #[available_gas(30000000)]
    fn spawn_test() {
        let (caller, world, actions_) = spawn_world();

        actions_.spawn();

        // Get player ID
        let player_id = get!(world, caller, (PlayerId)).player_id;
        assert(1 == player_id, 'incorrect id');

        // Get player score and remaining moves
        let (score, remaining_moves) = get!(world, player_id, (Score, RemainingMoves));
        assert(score.score == 0, 'incorrect score');
        assert(remaining_moves.moves == REMAINING_MOVES_DEFAULT, 'incorrect remaining moves');

        // get player id
        let tile = get!(world, (GRID_SIZE, GRID_SIZE, player_id), (Tile));
        assert(tile.player_id == player_id, 'Center tile is not set');
        assert(tile.tile_type == TileType::Castle, 'incorrect tile type');
    }

    #[test]
    #[available_gas(30000000000)]
    fn place_tile_test() {
        let (caller, world, actions_) = spawn_world();
        actions_.spawn();
        let tiles = array![
            (GRID_SIZE, GRID_SIZE + 1, TileType::Park),
            (GRID_SIZE, GRID_SIZE + 2, TileType::Park),
            (GRID_SIZE, GRID_SIZE + 3, TileType::Park)
        ];
        actions_.place_tile(tiles.span());
    }

    #[test]
    #[available_gas(30000000000)]
    #[should_panic(expected: ('duplicate tiles not allowed', 'ENTRYPOINT_FAILED'))]
    fn place_duplicate_tiles_test() {
        let (caller, world, actions_) = spawn_world();
        actions_.spawn();
        let tiles = array![
            (GRID_SIZE, GRID_SIZE + 1, TileType::Park),
            (GRID_SIZE, GRID_SIZE + 2, TileType::Park),
            (GRID_SIZE, GRID_SIZE + 1, TileType::Park),
        ];
        actions_.place_tile(tiles.span());
    }

    #[test]
    #[available_gas(300000000000)]
    #[should_panic]
    fn place_distant_tile() {
        let (caller, world, actions_) = spawn_world();
        actions_.spawn();
        let mut tiles = array![
            (GRID_SIZE + 1, GRID_SIZE + 1, TileType::Park),
            (GRID_SIZE + 2, GRID_SIZE + 2, TileType::Park),
            (GRID_SIZE + 2, GRID_SIZE + 3, TileType::Park),
        ];
        actions_.place_tile(tiles.span());
    }
// #[test]
// #[available_gas(300000000000)]
// #[ignore]
// fn remaining_moves_test() {
//     let (caller, world, actions_) = spawn_world();
//     actions_.spawn();
//     let player_id = get!(world, caller, (PlayerId)).player_id;
//     let tile1 = (GRID_SIZE, GRID_SIZE + 1, TileType::Park);
//     let tile2 = (GRID_SIZE - 1, GRID_SIZE, TileType::Park);
//     actions_.place_tile(tile1);
//     actions_.place_tile(tile2);
//     actions_.place_tile(tile3);

//     let remaining_moves = get!(world, player_id, (RemainingMoves)).moves;
//     assert(remaining_moves == REMAINING_MOVES_DEFAULT - 3, 'incorrect remaining moves');
// }

// #[test]
// #[available_gas(30000000)]
// #[ignore]
// fn neighbour_test() {
//     let (caller, world, actions_) = spawn_world();
//     let tile = get!(world, (0, 0, 0), (Tile));
//     tile.counted.print();
//     let neighbours = actions::get_neighbors(world, tile);
//     assert(neighbours.len() == 3, 'length should be 3');
// }
}
